

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/fluid.png">
  <link rel="icon" href="/blog/img/icon/dw.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Memory">
  <meta name="keywords" content="">
  
    <meta name="description" content="📝 真实经历，带你走进我的求职实习世界">
<meta property="og:type" content="article">
<meta property="og:title" content="从零开始：我的软工求职路">
<meta property="og:url" content="https://deng-2022.gitee.io/blog/2024/03/07/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%9A%E6%88%91%E7%9A%84%E8%BD%AF%E5%B7%A5%E6%B1%82%E8%81%8C%E8%B7%AF/index.html">
<meta property="og:site_name" content="Memory&#39;s blog">
<meta property="og:description" content="📝 真实经历，带你走进我的求职实习世界">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://deng-2022.gitee.io/blog/img/artical/nice_house.jpg">
<meta property="article:published_time" content="2024-03-07T00:37:07.000Z">
<meta property="article:modified_time" content="2024-03-07T00:37:07.000Z">
<meta property="article:author" content="Memory">
<meta property="article:tag" content="日记">
<meta property="article:tag" content="求职经验">
<meta property="article:tag" content="实习">
<meta property="article:tag" content="工作">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://deng-2022.gitee.io/blog/img/artical/nice_house.jpg">
  
  
  
  <title>从零开始：我的软工求职路 - Memory&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/blog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/blog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/blog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"deng-2022.gitee.io","root":"/blog/","version":"1.9.4","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/blog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 75vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/blog/">
      <strong>Memory&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/blog/img/newBG/girl.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="从零开始：我的软工求职路"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Memory
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-07 08:37" pubdate>
          2024年3月7日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          27k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          69 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="日记"
        id="heading-303a3ab7105ec97c68817c8deb89d16c" role="tab" data-toggle="collapse" href="#collapse-303a3ab7105ec97c68817c8deb89d16c"
        aria-expanded="true"
      >
        日记
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-303a3ab7105ec97c68817c8deb89d16c"
           role="tabpanel" aria-labelledby="heading-303a3ab7105ec97c68817c8deb89d16c">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="求职经验"
        id="heading-b61bd84ce59811eff662152594b2a496" role="tab" data-toggle="collapse" href="#collapse-b61bd84ce59811eff662152594b2a496"
        aria-expanded="true"
      >
        求职经验
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-b61bd84ce59811eff662152594b2a496"
           role="tabpanel" aria-labelledby="heading-b61bd84ce59811eff662152594b2a496">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="实习"
        id="heading-727190ad734e6dc9fcc55236742e41af" role="tab" data-toggle="collapse" href="#collapse-727190ad734e6dc9fcc55236742e41af"
        aria-expanded="true"
      >
        实习
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-727190ad734e6dc9fcc55236742e41af"
           role="tabpanel" aria-labelledby="heading-727190ad734e6dc9fcc55236742e41af">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="工作"
        id="heading-9a018b21ab114a51dd7b5979198a941b" role="tab" data-toggle="collapse" href="#collapse-9a018b21ab114a51dd7b5979198a941b"
        aria-expanded="true"
      >
        工作
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-9a018b21ab114a51dd7b5979198a941b"
           role="tabpanel" aria-labelledby="heading-9a018b21ab114a51dd7b5979198a941b">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/blog/2024/03/07/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%9A%E6%88%91%E7%9A%84%E8%BD%AF%E5%B7%A5%E6%B1%82%E8%81%8C%E8%B7%AF/" title="从零开始：我的软工求职路"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">从零开始：我的软工求职路</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">从零开始：我的软工求职路</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>三月份了，春招在即，我也开始着手准备今年下半年的秋招了。</p>
<p>现阶段的目标是能在短期内找到一份日常实习，再持续投递中大厂的暑期实习岗位。</p>
<p>这注定是一场持久战，从现阶段开始到接下来的九个月里，我不能有丝毫懈怠。</p>
<p>那么，简单记录下我的求职经历吧！</p>
<h2 id="求职经历"><a href="#求职经历" class="headerlink" title="求职经历"></a>求职经历</h2><p>2月19日，了解计算机四级网络工程师考点考纲，基本完成项目网站首页，记忆 MySQL 相关八股文，计划开始优化简历。</p>
<p><strong>大三下还打算窝在学校上课，是等着毕业就失业吗？</strong></p>
<p>2月20日，系统分析项目核心功能，优化简历“专业技能”一栏，现阶段第一版简历完成，目标更加清晰；巩固 Spring 相关八股文。</p>
<p>2月21日，着手梳理 Memory API 忆汇廊核心功能；想家了，有感而发，写点生活感悟。</p>
<p>2月22日，着手配置 Canal 监听 MySQL 数据库流水；巩固蓝桥杯考点考纲，了解蓝桥杯算法，做好备考；持续完善项目文档以及 Gitee / GitHub 仓库介绍。</p>
<p>2月23日，记忆 Java、JVM 相关八股文；下午跟小穆聊天，唠家常，唠理想；梳理项目核心功能；尝试 Spring Cloud Gateway 限流。</p>
<p><strong>晚风几许撩人意，夕阳半刻醉人心</strong></p>
<p>2月24日，完善项目架构设计，思考项目优化点和扩展点；梳理项目核心功能，持续优化项目文档以及 Gitee / GitHub 仓库介绍；掘金学习热榜文章：自定义 Starter、MySQL 日志、事务相关知识；计划开始持续输出文章，记录生活；晚点时候，拿到电信流量卡并成功激活。</p>
<p><strong>强者，从来不会抱怨环境。我他妈就是强者</strong></p>
<p>2月25日，简单的早间点滴；第一次来餐厅自习；完善计算机网络八股，开始阅读《HTTP四十讲》；着手购买充电宝、便携式桌椅，为面试做准备。</p>
<p><strong>没有什么光阴真正被虚度，也没有任何事情是徒劳无功的</strong></p>
<p>2月26日，在牛客、BOSS、实习僧等了解行情；持续学习计算机网络；基本完成项目文档编写，完善 SDK Gitee 项目介绍；阅读《孙子兵法》《朝花夕拾》。</p>
<p><strong>知识改变年薪，文化改变命运</strong></p>
<p>2月27日，六级三战失败，血压暂时升高；优化简历“专业技能”一栏，添加设计模式、个人优势等内容；一次性完善“项目经历”一栏内容，简历第二版优化完成；持续巩固计算机网络和 Redsi；过牛客链表算法题；计划明天彻底完善简历，打点校园内的面试环境。</p>
<p><strong>截至二零二四年二月二十七日，下午四时四十五分，我的个人博客共有七十余篇博文，总计九百余张图片、五十余万文字</strong></p>
<p>2月28日，快速记忆 Java 基础、Spring 常考面试题；完善实习僧平台信息；基本完善项目文档，优化简历；成功投递第一波简历。</p>
<p>2月29日，持续巩固学习 MySQL、Redis、并发编程、集合等八股；持续投递本地日常实习；沟通几十个、简历几份，到目前为止还没有回应；学习 RPC、网关等微服务架构知识，系统梳理。</p>
<p>3月1日，远程帮助小伙伴完善项目，持续学习微服务架构；终于有人要我简历了，很期待；桌子，椅子，超大容量充电宝都回来了；写点故事；</p>
<p>3月2日，跑步半小时，连续三天在 BOSS 打招呼，计划找个本地实习，但基本已读不回；做京东笔试题；学习链表算法题；头疼，下午补觉；植物大战僵尸汉化版，休息。</p>
<p>3月3日， BOSS 求职回复寥寥无几，心情越发浮躁；晚上读书，计划明天投递第四波简历。</p>
<p>3月4日，学习 Java 并发编程，学习记录 JVM；谈谈我对微服务架构的理解；下午实习僧一键投递，很快啊，投了五十多份简历；实习僧收到一份七号中午的笔试邀请。</p>
<p>3月5日，继续学习 JVM；前两次要简历的都抱歉了；BOSS 有回复，要求 Java 实习转 GO，无薪资，没有后续；学习 Maven 项目管理工具；计划明天开始投递中大厂，基本放弃本地实习机会。</p>
<p>3月6日，了解租房经验；实习僧约了八号下午四点的面试，人生第一次面试，既紧张又兴奋；准备自我介绍；巩固 MySQL 八股文（索引、事务、锁）；巩固 Spring 八股文；晚上吃泡面。</p>
<p>3月7日，计划投递腾讯实习岗位，完善作品集；开设新博文，记录我的求职经历；完成始祖象的笔试；完成携程招聘笔试题，笔试题还挺有意思；同尹老师交流，介绍了个学长，下午吃饭前给学长投了份简历；中午投递 BOSS，约了下周一的线下面试；学习计算机网络。</p>
<p>3月8日，写日记，好久没写日记了；上午尝试投递 BOSS，又有位 BOSS 肯理我了，现在还没有实习岗位，把我简历要过去了。一周之内如果有实习岗位，就会有答复；下午四点腾讯会议面试，第一次面试，时长三十五分钟，问得比较简单，就是没啥经验，话到嘴边表达不清楚的感觉，还得继续努力呵；始祖象算法工程师岗位又发来笔试邀请了，15号的笔试；根据京东大佬指点意见，优化简历。</p>
<p>3月9日，面向面经复习；简历优化，内容更加精炼；写会儿大学故事；在安居乐租房软件上了解租房动态，上B站了解租房注意事项；下午继续 BOSS 投递，又成功投出去一份简历；跟小穆聊天，分享求职进展；晚上面向面经，查缺补漏。</p>
<p>3月10日，跑步，半小时；备考计算机四级网络工程师；面向面经复习；调试鱼聪明，竟然还要再充会员嘛；中午投递一波简历，又有一份回应；</p>
<h2 id="重点知识总结"><a href="#重点知识总结" class="headerlink" title="重点知识总结"></a>重点知识总结</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><strong>简单介绍一下 ArrayList</strong>：</p>
<p>实现了 RandomAccess 接口，支持随机访问；实现了 Clonable 接口，支持复制；实现了 Serializable，支持序列化传输。</p>
<p>底层使用数组实现，该数组为可变长数组，也称之为动态数组。默认初始容量为10，超出容量限制会自动扩容1.5倍。</p>
<p>扩容就是新建一个1.5倍容量大的数组，把原数组内容拷贝到新数组中，将新数组作为扩容后的数组。数组扩容代价很高，使用时应该尽量避免数组扩容，要预知要保存元素的多少，构建 ArrayList 时就指定其初始容量。</p>
<p>remove() 方法有按照索引删除，也有按照元素值删除。会使从所删除元素的下标开始，到数组末尾的元素全部向前移动一个位置，置空最后一位，方便 GC 回收。删除中间元素，需要挪动大量的数组元素，操作代价很大；如果是末尾元素，代价是最小的。</p>
<p>不是线程安全的，只能用在单线程环境下。在多线程环境中，可以考虑使用 Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList 类。</p>
<p>采用了Fail-Fast机制，面对并发的修改时，迭代器很快就会完全失败，报异常 concurrentModificationException(并发修改一次)</p>
<p><strong>add(E e) 实现原理</strong>：</p>
<p>ensureCapacityInternal(size +1)，修改 modCount 标识自增一，calculateCapacity() 确保数组已使用长度加一后不会溢出，即足够存放下一个元素，不满足就使用 grow() 扩容为原容量的1.5倍。</p>
<p>ElementData[size++] = e，添加新元素到数组中。</p>
<p>返回新元素添加成功的布尔值。</p>
<p><strong>add(int index, E element) 实现原理</strong>：大同小异。</p>
<p>首先确保要插入元素的位置小于等于当前数组长度，并且不能小于0，否则抛出异常。</p>
<p>判断是否需要扩容后，确保了数组有足够的容量。使用 System.arraycopy() 将要插入的位置之后的所有元素向后移动一位，再将新的数组元素放到指定位置 ElementData[index] = e。</p>
<p><strong>扩容原理</strong>：ArrayList的扩容原理主要涉及到底层数组的容量调整。当ArrayList中的元素数量达到当前数组的容量时，它会自动进行扩容以容纳更多的元素。</p>
<p>具体来说，ArrayList的扩容过程如下：</p>
<ol>
<li><strong>计算新容量</strong>：默认情况下，新的容量会是当前容量的1.5倍。这通常是通过将当前容量右移一位（相当于除以2）然后加上当前容量来实现的。例如，如果当前容量是10，那么新的容量会计算为10 + (10 &gt;&gt; 1) = 15。</li>
<li><strong>创建新数组</strong>：根据计算出的新容量，ArrayList会创建一个新的数组。</li>
<li><strong>复制元素</strong>：将原数组中的元素复制到新数组中。这个过程涉及到遍历原数组，并将每个元素依次放入新数组的对应位置。</li>
<li><strong>更新引用</strong>：将ArrayList的内部引用从原数组更新为新数组。</li>
</ol>
<p>需要注意的是，ArrayList在初始化时会有一个默认的容量（通常为10），当第一个元素被添加时，如果还没有进行初始化，那么就会创建一个默认容量的数组。之后的扩容操作都是基于这个原理进行的。</p>
<p>频繁的扩容操作可能会对性能产生影响，因为每次扩容都需要创建新数组并复制元素。因此，在实际使用中，如果可能的话，最好预先估计所需容量并设置合适的初始容量，以减少扩容的次数。</p>
<p>另外，与ArrayList不同，LinkedList是基于双向链表实现的，因此它不需要扩容机制。在LinkedList中，添加或删除元素只需要调整链表的节点连接，而不需要像ArrayList那样复制整个数组。这使得LinkedList在元素增加和删除操作上的效率通常比ArrayList要高。</p>
<p><strong>remove() 的实现过程</strong>：从列表中删除指定元素，有多种重载形式。按值删除，遍历整个列表寻找给定元素，找到就删除，同时将后面元素向前移动一个位置。按索引删除，直接定位到给定索引的元素，执行删除操作。</p>
<p><strong>remove() 的实现原理</strong>：以按照索引删除为例。ElementData 数组根据索引下标找到元素值；根据 size - index - 1 判断删除元素是否为最后一个元素。如果不是最后一个元素，执行 System.arraycopy() 数组拷贝，所有元素向前移动一个位置。最后，把数组最后一位置空，为 null，为 GC 做准备。</p>
<p><strong>Fail-Fast 机制</strong>：这是一个错误检测机制，用于在并发修改列表时抛出 <code>ConcurrentModificationException</code> 异常。</p>
<p>当使用迭代器遍历 <code>ArrayList</code> 时，如果列表在迭代过程中被结构性地修改了（例如，通过 <code>add</code>、<code>remove</code> 或 <code>clear</code> 方法），迭代器就会快速失败并抛出 <code>ConcurrentModificationException</code>。结构性修改是指那些改变列表大小的操作，或者那些可能干扰迭代器行为的操作。</p>
<p>这种机制的实现依赖于 <code>ArrayList</code> 内部的一个 <code>modCount</code> 字段。每当列表被结构性修改时，<code>modCount</code> 就会增加。迭代器在每次迭代时都会检查 <code>modCount</code> 是否与迭代器创建时的 <code>expectedModCount</code> 相等。如果不相等，就抛出 <code>ConcurrentModificationException</code>。</p>
<p>如果你尝试在迭代过程中使用 <code>list.remove(item)</code> 来删除元素，就会触发 Fail-Fast 机制并抛出异常。因此，总是应该使用迭代器的 <code>remove</code> 方法来删除元素，当你需要在迭代过程中修改列表时。</p>
<p>虽然 Fail-Fast 机制可以帮助发现并发问题，但它并不是线程安全的解决方案。在多线程环境中，你仍然需要使用适当的同步机制（如 <code>synchronized</code> 块或 <code>Collections.synchronizedList</code>）来确保线程安全。Fail-Fast 机制主要是为了帮助开发者在开发过程中更早地发现并发问题，而不是作为一个完整的并发控制机制。</p>
<p><strong>循环中删除 ArrayList 的元素</strong>：</p>
<ol>
<li>使用<code>ArrayList</code>的<code>remove</code>方法直接删除元素：普通 for 循环通常是通过索引来遍历数组或容器中的元素的，而在循环中删除元素，列表的大小会改变，后续元素会向前移动，可能会抛出数组越界异常问题。</li>
<li>使用迭代器的<code>remove</code>方法：Fail-Fast 机制</li>
<li>使用增强型for循环删除元素：增强型for循环（也称为”foreach”循环）在内部使用迭代器，因此当在循环体内部使用<code>ArrayList</code>的<code>remove</code>方法时，会抛出<code>ConcurrentModificationException</code>。</li>
<li>从列表末尾向前删除元素：这种从后向前迭代的方法特别适用于需要基于索引删除元素的情况，因为它不会受到删除元素后列表大小变化的影响。</li>
</ol>
<p>普通for循环本身不会抛出<code>ConcurrentModificationException</code></p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>​    类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。 字节码可以是 Java 源程序（<code>.java</code>文件）经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p>
<p>类加载机制</p>
<p>​    首先要明确的一点是，JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</p>
<p>​    对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>
<p>类加载器分类</p>
<p>​    JVM 中内置了三个重要的 <code>ClassLoader</code>：<code>BootstrapClassLoader</code>(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库；<code>ExtensionClassLoader</code>(扩展类加载器)；<code>AppClassLoader</code>(应用程序类加载器)：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。</p>
<p>双亲委派模型</p>
<p>​    每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p>
<ul>
<li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li>
<li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li>
<li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li>
<li>如果子类加载器也无法加载这个类，那么它会抛出一个 <code>ClassNotFoundException</code> 异常</li>
</ul>
<p>​    双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载。原因是这样的：JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类。JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。</p>
<p>打破双亲委派模型</p>
<p>​    自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>
<p>​    我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p>
<h3 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h3><p>运行时数据区域</p>
<p>程序计数器：字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p>
<p>虚拟机栈：方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p>
<ul>
<li><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型和对象引用。</li>
<li><strong>操作数栈</strong> 用于存放方法执行过程中产生的中间计算结果和计算过程中产生的临时变量。</li>
<li><strong>动态链接</strong> 用于管理调用其他方法的符号引用，主要服务一个方法需要调用其他方法的场景。</li>
</ul>
<p>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</p>
<p>堆：Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p>
<p>方法区：当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
<p>运行时常量池：Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p>
<p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。常量池表会在类加载后存放到方法区的运行时常量池中。</p>
<p>以前在永久代即运行时数据区域，现在存放在元空间即本地内存。</p>
<p>字符串常量池：<strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。以前在永久代即运行时数据区域，现在存放在堆中。</p>
<p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<p>直接内存：直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>如果 TLAB 中没有足够的内存空间，就会在共享 Eden 区（shared Eden space）之中分配。如果共享 Eden 区也没有足够的空间，就会触发一次 年轻代 GC 来释放内存空间。如果 GC 之后 Eden 区依然没有足够的空闲内存区域，则对象就会被分配到老年代空间（Old Generation）。</p>
<p>各种垃圾收集器的实现细节虽然并不相同，但总体而言，垃圾收集器都专注于两件事情：</p>
<ul>
<li>查找所有存活对象</li>
<li>抛弃其他的部分，即死对象，不再使用的对象。</li>
</ul>
<p>第一步，记录（census）所有的存活对象，在垃圾收集中有一个叫做 <strong>标记（Marking）</strong> 的过程专门干这件事。</p>
<p><strong>标记</strong> 阶段完成后，GC 进行下一步操作，删除不可达对象。</p>
<p>删除不可达对象（Removing Unused Objects）</p>
<p>各种 GC 算法在删除不可达对象时略有不同，但总体可分为三类：清除（sweeping）、整理（compacting）和复制（copying）。[下一小节] 将详细讲解这些算法。</p>
<h3 id="Java-对象的创建过程"><a href="#Java-对象的创建过程" class="headerlink" title="Java 对象的创建过程"></a>Java 对象的创建过程</h3><p>类加载检查：遇到一条 new 指令，指定实例化哪个类，检查该类是否已经加载完成。如果没有，先执行类加载操作。</p>
<p>分配内存：类加载完成，即类加载检查通过后，在堆中为实例对象划分空间，分配内存。根据不同的垃圾回收机制，如果存在内存碎片，即堆内存不规整，虚拟机会维护一个列表分配一块连续的存储空间。如果不存在内存碎片，虚拟机会使用分界指针找到空闲的内存区域来分配内存空间。</p>
<p>初始化零值：虚拟机将所分配的所有内存空间全部初始化零值，实现了对象实例的成员属性有默认值，不赋初始值就能直接使用。</p>
<p>设置对象头：要确保如何根据实例对象找到该对象对应的类，需要设置对象头。对象头中包括了类信息、GC 分代收集年龄、对象哈希码等内容。</p>
<p>执行构造方法：按照程序员意愿初始化对象，至此，Java 对象创建完成。</p>
<p>MySQL</p>
<h3 id="网络传输安全"><a href="#网络传输安全" class="headerlink" title="网络传输安全"></a>网络传输安全</h3><p>防止窃听，机密性</p>
<ul>
<li>对称加密算法：通信双方使用唯一的密钥来加密通信数据。</li>
</ul>
<blockquote>
<p>问题：通信之前，如何把用来加密数据的密钥安全地传输给对方？无法保证。</p>
</blockquote>
<ul>
<li>非对称加密算法：通信双方各持有一个密钥对，公钥是公开的，私钥自己持有。使用对方的公钥加密数据，只有对方才能用私钥解密</li>
</ul>
<blockquote>
<p>问题：非对称算法的运算速度很慢、性能很差，如果传输过程中频繁使用非对称加密算法加密数据，网络的传输效率是很低的</p>
</blockquote>
<ul>
<li>混合加密：将对称加密算法和非对称加密算法结合，通信开始前使用双方使用非对称加密方式传输密钥，保证了密钥的安全传输，此后通信双方可以使用该密钥来加密通信数据，保证了通信数据的保密性。</li>
</ul>
<p>防止篡改，完整性</p>
<ul>
<li>摘要算法：一种特殊的单向加密的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。摘要和原数据是完全等价的，加密后的数据无法解密，不能从摘要逆推出原文。发送方把加密后的数据，使用摘要算法生成摘要，把加密数据和该摘要一同发往接收方。接收方使用同样的摘要算法对加密数据进行计算，比照生成的摘要和接受的摘要是否一致，保证了通信数据的完整性。</li>
</ul>
<p>身份认证，真实性</p>
<ul>
<li><p>数字签名：发送方要保证通信数据是真实可信的，不是别人伪造的。使用自己的私钥对摘要加密，生成数字签名。数字签名和加密数据被一同发往接收方。接收方使用发送方的公钥解密，验证签名，拿到摘要，再比对原数据验证完整性。这样就可以像签署文件一样，证明消息确实是发送方发的。</p>
</li>
<li><p>数字证书：接收方能够使用公钥验签，但是公钥是公开的。我们还缺少防止黑客伪造公钥的手段，也就是说，怎么来判断这个公钥就是发送方的公钥呢？CA（证书认证机构）具有极高的可信度，由它来为各个公钥签名，这样的公钥就是可信的。CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成数字证书。</p>
</li>
<li><p>通信双方的数据是加密传输的，保证了数据是保密的，没有被窃听；使用摘要保证了数据的完整性，没有被篡改；使用数字签名，保证了发送方的身份是可靠的，没有被伪造；使用数字证书，保证了接收方的身份是可信的。</p>
</li>
</ul>
<h3 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h3><p>熟悉 Redis 基础知识：什么是 Redis，Redis 为什么这么快，Redis 线程模型，Redis 内存管理，Redis 底层数据结构</p>
<h3 id="Redis-缓存"><a href="#Redis-缓存" class="headerlink" title="Redis 缓存"></a>Redis 缓存</h3><p>熟悉常见的生产问题：缓存雪崩，缓存击穿，缓存穿透，保证 Redis 缓存和数据库的一致性（即 Redis 读写策略）</p>
<h3 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h3><p>AOF 日志：</p>
<p>写后日志，先执行命令，后写日志，然后把日志写入内存缓冲区，在合适的时机刷入磁盘（避免写入错误的命令，减小检查开销；不会阻塞当前的写入操作）</p>
<p>写后日志也会带来问题：不阻塞当前写操作，但可能会阻塞后面的写操作；先执行命令后，服务挂了，日志没有及时写入。这就要研究 AOF 写入磁盘的时机了。</p>
<p>同步写回：每条命令执行完毕，立刻写回磁盘；每秒写回：每隔一秒把缓冲区内容写回磁盘；不写回，由操作系统判断合适的时机写回磁盘。这三种策略性能越来越好，对主线程的影响越来越小；但数据完整性越来越差，可能导致更多的数据丢失，无法及时写回磁盘。</p>
<p>随着写命令越来越多，AOF 文件会越来越大：文件过大，无法保存；文件过大，追加命令的效率变低；文件过大，数据恢复效率变低。</p>
<p>Redis AOF 重写日志。AOP 日志记录的内容就是具体的键值和命令，扫描整个日志文件，只保存最新的数据：把旧文件中的多条命令，改写为一条命令，减小日志文件体量。</p>
<p>AOF 重写日志也会阻塞主线程，重写的过程很有趣（一次拷贝，两个日志）：</p>
<p>总的来说，AOF 日志文件能很好地保证数据完整性，尽最大限度减少数据丢失，但数据恢复有点慢。</p>
<p>RDB 快照：</p>
<p>直接记录某一时刻的数据，写入内存中，再写回磁盘。</p>
<p>我们要对哪些数据做快照？快照期间，数据还能变化吗？</p>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。save 会阻塞主线程，bgsave 会创建一个子线程，专门用来执行全量快照。</p>
<p>写时复制机制：现在保证了执行快照期间，可以不阻塞主线程。那么如何保证执行快照的同时，主线程也能正常执行写操作，变化数据呢。</p>
<p>写时复制机制保证快照期间数据可修改，这个过程也很有趣（拟修改，数据副本）：</p>
<p>如何控制快照频率？频繁地执行全量快照写入磁盘，会给磁盘带来很大压力。可以执行增量快照，只写入变化的数据。这就需要记住哪些数据被修改（键值对），也会带来空间性能开销。</p>
<p>总的来说，RDB 快照实现了数据的快速恢复，但是不能很好的保证数据的完整性，因为频率不好把控。</p>
<p>混合持久化：设置合适的快照间隔，在两次快照的间隔期间，使用 AOF 日志持久化。AOF 日志能很好地解决两次快照期间的数据丢失问题，当第二次快照执行完毕，前一次 AOF 日志就可以直接清空，使用新的 RDB 快照进行快速回复就行了。这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令、尽可能保证数据不丢失的简单优势。</p>
<h3 id="Redission-分布式锁"><a href="#Redission-分布式锁" class="headerlink" title="Redission 分布式锁"></a>Redission 分布式锁</h3><p>解决问题：分布式锁，即分布式系统中的锁，主要用于在分布式系统中控制共享资源的访问。</p>
<p>主要基于 Redis 的setnx 命令实现，还使用 lua 脚本保证了释放锁的原子性。</p>
<p>实现原理：</p>
<p>多个客户端同时竞争锁。客户端在尝试获取锁时，向 Redis 发送 setnx 命令，设置一个随机的 UUID 作为 value。如果设置成功，则说明该客户端抢到锁了，可以执行临界区的代码。如果设置失败，客户端可以选择等待一段时间再次获取，或者直接立即返回。临界区代码执行完毕，该客户端需要释放锁，使用 lua 脚本实现正确释放锁，保证释放锁的原子性。为了防止执行过程中崩溃导致锁无法及时释放，还实现了锁的自动续期机制。使用定时任务，当客户端持有锁时，延长锁的过期时间。用户释放锁，就取消定时任务，直接释放锁。</p>
<p>使用步骤：根据 key 创建锁对象，并在临界区代码前后分别调用lock()和unlock()方法来获取和释放锁。</p>
<h3 id="Reddssion-分布式限流"><a href="#Reddssion-分布式限流" class="headerlink" title="Reddssion 分布式限流"></a>Reddssion 分布式限流</h3><p>解决问题：在分布式系统中，对系统的访问进行限流，以避免过多的请求导致系统崩溃。</p>
<p>主要基于 Redis 的list 数据结构实现，还使用 lua 脚本保证获取和释放令牌的原子性。</p>
<p>实现原理：</p>
<p>当客户端请求到达，会向 Redis 发送一个 lua 脚本尝试获取令牌，即往 list 数据结构中添加一个元素，list 容量反映了令牌发放的数量。客户端成功获取到令牌，就可以进行接下来的操作。如果 list 已满，即达到最大容量，客户端就获取不到令牌。此时客户端可以选择等待、重试。为了防止令牌堆积，实现了令牌的过期机制，当令牌存在的时间超过一定阈值，就会自动移除令牌。</p>
<p>使用步骤：根据 key 创建限流器对象，设置每秒生成多少令牌，刷新间隔为多少，调用tryAcquire()方法尝试获取令牌。</p>
<p><strong>常见的限流算法</strong>：主要包括计数器限流、滑动窗口限流、漏桶限流和令牌桶限流。这些算法都用于控制接口或服务的访问频率，以避免系统过载或崩溃。</p>
<ol>
<li>计数器限流<ul>
<li>原理：在固定时间段内记录并限制接口调用的次数。例如，设定每分钟只能调用100次接口。</li>
<li>实现：每次接口被调用时，计数器加1。如果当前时间与第一次调用时间的间隔不超过设定时间段（如1分钟），且计数器超过限定的次数（如100次），则拒绝新的调用。</li>
<li>缺陷：在时间段临界值附近，如果请求密集，可能导致单位时间内调用次数超过限流次数。</li>
</ul>
</li>
<li>滑动窗口限流<ul>
<li>原理：以时间窗口为滑动单位，记录并限制在窗口时间内的接口调用次数。</li>
<li>实现：窗口随时间滑动，每次检查当前时间窗口内的调用次数是否超过限定值。</li>
<li>优点：解决了计数器限流在临界值附近的问题。</li>
</ul>
</li>
<li>漏桶限流<ul>
<li>原理：将请求比作水，漏桶比作系统处理能力。无论流入多少水，漏桶流出的水是恒定的。</li>
<li>实现：请求按照固定速率流出，当请求流入速率超过漏桶的流出速率时，多余的请求会被拒绝。</li>
<li>特点：限制了请求的流出速率，平滑了突发请求。</li>
</ul>
</li>
<li>令牌桶限流<ul>
<li>原理：系统以固定速率往令牌桶中添加令牌，每次请求需要消耗一个令牌。</li>
<li>实现：如果请求到来时桶中有令牌，则消耗一个令牌并处理请求；否则，拒绝请求。</li>
<li>特点：允许一定程度的突发流量，只要桶中有令牌就可以处理请求。</li>
</ul>
</li>
</ol>
<p>这些限流算法各有特点，选择哪种算法取决于具体的业务场景和需求。例如，计数器限流实现简单但可能存在临界值问题；滑动窗口限流解决了临界值问题但实现相对复杂；漏桶限流平滑了突发请求但可能限制了系统的处理能力；令牌桶限流则允许突发请求并提供了较好的灵活性。</p>
<h3 id="Redission-分布式-session"><a href="#Redission-分布式-session" class="headerlink" title="Redission 分布式 session"></a>Redission 分布式 session</h3><p>Java 并发容器</p>
<h3 id="介绍项目难点"><a href="#介绍项目难点" class="headerlink" title="介绍项目难点"></a>介绍项目难点</h3><p>API 项目介绍：分为四个模块：api-core，实现用户管理、接口管理、接口调用等；api-gateway，做统一的访问控制、流量染色、用户鉴权，完成统一登录校验、API 签名校验、接口调用统计呵请求响应前后的日志处理；api-client，自主设计对外提供接口服务；api-common，抽象公共接口 / 方法、公共实体类。</p>
<p>使用 Maven聚合工程管理子模块，都需要在本地 install。接口调用的逻辑：请求 api-core 的接口调用服务：首先校验参数，判断接口是否存在。获取当前登录用户，拿到 ak 和 sk，以此作为参数构建 SDK 客户端。SDK 客户端通过封装请求参数（包含用户信息、调用接口信息），使用 Hutool 工具包，发送请求到网关。</p>
<p>网关实现全局过滤，获取请求头的一切信息：请求参数、请求路径、请求来源地址等。做 API 签名校验，鉴定用户身份；根据请求路路径和方法判断接口状态，是否存在，是否发布或下线；设置 ip 黑白名单，只允许当前服务器的请求可以通过；流量染色，给请求添加统一的请求头。完成一系列校验之后，将该合法请求转发给真正的接口服务，处理接口调用，返回响应。最后在 haddleReponse 响应处理器中，完成接口调用统计等业务逻辑，更新相关字段，比如用户剩余调用次数、接口调用总次数等。返回响应，结束整个调用流程。</p>
<p>不希望引入复杂的业务逻辑，为减小网关模块体量，遵循单一原则，抽象公共业务逻辑和公共实体类到 api-common 模块。引入 Dubbo 轻量的 RPC 框架，用 EnabbleDubbo、@DubboReference、@DubboServie 等，使用 Nacos 做注册中心，实现服务注册。网关服务作为消费者实现服务拉取。实现服务间方法调用。</p>
<h3 id="TCP-三次握手-四次挥手扩展问题"><a href="#TCP-三次握手-四次挥手扩展问题" class="headerlink" title="TCP 三次握手 / 四次挥手扩展问题"></a>TCP 三次握手 / 四次挥手扩展问题</h3><p>TCP 连接三次握手的过程是怎样的？</p>
<p>TCP 是面向连接的协议，使用 TCP 前必须建立连接。</p>
<ul>
<li>一开始，客户端和服务端都处于 CLOSE 状态。</li>
<li>服务端主动监听某端口，进入 LISTEN 状态。</li>
<li>客户端随机初始化序号（c1），即 TCP 报文首部的序号字段，同时把同步标志位置为1，表示这是一个 TCP 连接请求报文。接着客户端把该报文发往服务端，表示向服务端发起连接，之后客户端进入同步已发送状态。</li>
<li>服务端收到客户端的 TCP 连接请求报文。</li>
<li>服务端首先初始化序号（s1），即 TCP 报文首部的序号字段；然后初始化确认应答号为 c1 + 1，表示该序号之前的内容全部接收完成，期望收到该序号之后的报文。同时把同步标志位和确认标志位置为1，表示这是一个 TCP 连接响应报文。最后把该报文发往客户端，表示已收到并回应客户端的连接请求，之后服务端进入同步已接收状态。</li>
<li>客户端收到服务端的 TCP 连接响应报文。</li>
<li>客户端还要向服务端发送最后一个应答报文，这个报文是普通的 TCP 报文。客户端设置确认应答号为 s1 + 1，同时设置确认标志位为1，表示这是一个普通的 TCP 应答报文。客户端把该报文发往服务端，这次报文可以携带客户端的数据到服务端，之后客户端进入已连接状态。</li>
<li>服务端收到客户端的应答报文后，也进入已连接状态。</li>
</ul>
<p>一旦完成三次握手，双方都处于已连接状态，连接建立完成，客户端和服务端就可以相互发送数据了。</p>
<p>TCP 四次挥手的过程是怎样的？</p>
<p>双方都可以主动断开连接，以客户端主动断开连接为例。</p>
<ul>
<li>客户端打算关闭连接，把终止标志位置为1，表示这是一个连接终止请求报文。客户端把该报文发往服务端，进入终止等待1状态。</li>
<li>服务端收到该报文，向客户端发送普通的 TCP 应答报文，之后服务端进入关闭等待状态。</li>
<li>客户端收到服务端的应答报文，之后进入终止等待2状态。</li>
<li>等待服务端处理完数据，服务端再把终止标志位置为1，向客户端发送连接终止请求报文，之后服务端进入最后等待状态。</li>
<li>客户端收到该报文，再次往服务端发送一个普通的 TCP 应答报文，之后客户端进入时间等待状态。</li>
<li>服务端收到该应答报文，之后进入关闭状态，至此服务端已经完成了连接的关闭。</li>
<li>客户端在经过 2MSL（最大报文存活时间）后，自动进入关闭状态，至此客户端也完成了连接的关闭。</li>
</ul>
<h3 id="JWT-原理"><a href="#JWT-原理" class="headerlink" title="JWT 原理"></a>JWT 原理</h3><h3 id="Session-Cookie"><a href="#Session-Cookie" class="headerlink" title="Session / Cookie"></a>Session / Cookie</h3><h3 id="性能优化方案"><a href="#性能优化方案" class="headerlink" title="性能优化方案"></a>性能优化方案</h3><p>代码层面优化</p>
<p>系统层面优化</p>
<p>数据库层面优化</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="Mybatis-工作流程"><a href="#Mybatis-工作流程" class="headerlink" title="Mybatis 工作流程"></a>Mybatis 工作流程</h3><p>加载配置文件：读取MyBatis的配置文件（mybatis-config.xml），包含全局配置信息：运行环境、数据库连接信息。加载映射文件，包含将要执行的 SQL 语句。</p>
<p>构建会话工厂：即创建SqlSessionFactory：使用配置文件创建SqlSessionFactory对象，该对象负责创建创建会话对象 SqlSession。</p>
<p>创建会话对象，根据会话工厂 SqlSessionFactory获取SqlSession对象，SqlSession包含了执行 SQL 的所有方法，代表一次会话。</p>
<p>执行映射文件：使用会话对象 SqlSession ，根据 Mybatis 提供的 API（增删改查语句），执行映射文件中定义的SQL语句。</p>
<p>处理操作结果：解析传入的参数，构建最终要执行的 SQL 语句，获取数据库连接，执行 SQL，将SQL执行的结果进行转换，映射为Java对象或集合。</p>
<p>返回处理结果：释放与数据库的连接资源，关闭会话对象 SqlSession，返回最终的处理结果。</p>
<h3 id="Spring-MVC-工作原理"><a href="#Spring-MVC-工作原理" class="headerlink" title="Spring MVC 工作原理"></a>Spring MVC 工作原理</h3><p>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</p>
<p><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p>
<p><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</p>
<p><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p>
<p><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</p>
<p><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p>
<p>把 <code>View</code> 返回给请求者（浏览器）</p>
<h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><h3 id="Spring-的启动流程"><a href="#Spring-的启动流程" class="headerlink" title="Spring 的启动流程"></a>Spring 的启动流程</h3><p>Spring 的启动流程大致有以下几个关键步骤：</p>
<p>加载配置文件：Spring 在启动时，首先加载其 XML 格式的配置文件，配置文件中定义了 Spirng 容器中管理的 Bean 属性以及依赖关系。</p>
<p>解析配置文件：加载完配置文件，由 XML 解析器将将配置文件中的 Bean 定义转化为 Spring 容器可以理解和使用的内部数据结构。</p>
<p>创建并初始化 Bean：根据解析得到的 Bean 定义，Spring 开始创建相应的 Bean 实例，进行初始化，包括设置属性值、处理依赖关系。</p>
<p>注册 Bean：Bean 初始化完成会被注册到 Spring 容器中，其他 Bean 就可以通过容器获取这些 Bean 引用进行使用，这就是依赖注入。</p>
<p>至此，当所有的 Bean 都创建并初始化完成后，Spring 启动完成，可以对外提供服务了。</p>
<p>Spring Boot 的启动流程跟 Spring 的启动流程在核心逻辑上基本上是一致的，但存在一些差异：</p>
<p>自动化配置：传统的 Spring 应用程序，需要在 appicationContext.xml 或者 mybatis-config,xml 中手动配置数据源，包括数据库 URL、用户名、密码等，很繁琐。而 Spring Boot 提供了自动配置功能：导入 jar 包依赖，在 resource 下的 yaml / properties 配置文件里简单地写清楚配置。Spring Boot 就会自动创建已经配置好的数据源 Bean，不再需要手动配置数据源。</p>
<p>简化依赖管理：Spring Boot 提供了一系列 starter 依赖，，只需要在项目中引入 starter 依赖，Spring Boot 便会自动引入所需的库。不再需要自己处理复杂的依赖关系，比如解决依赖冲突、版本兼容等问题，大大简化了依赖管理。</p>
<p>内嵌服务器：不同于 Spring 需要开发者手动配置和部署 Web 服务器。Spring Boot 内嵌了常用的 Web 服务器（如 Tomcat、Jetty 等），使得开发者无需单独配置和部署 Web 服务器。只需导入 jar 包依赖（GAV 坐标），在 resource 的 yaml / properties 配置文件中指定监听端口，在启动 Spring Boot 应用程序时，内置服务器就会自动启动并监听相应的端口。</p>
<p>快速启动：由于 Spring Boot 的自动化配置、简化依赖管理、内嵌服务器等，只需要直接运行 @SpringBootApplication 标注的启动类，就可以一键启动 Spring Boot 应用程序。</p>
<p>简化部署：通过一行命令：java -jar 等即可快速将 Spring Boot应用程序打包成一个可执行的 JAR 或 WAR 文件。再将打包好的文件复制到目标服务器上，通过一行命令就可以一键启动，部署变得十分简单和方便。</p>
<h3 id="Spring-自动配置原理"><a href="#Spring-自动配置原理" class="headerlink" title="Spring 自动配置原理"></a>Spring 自动配置原理</h3><p><strong>Starter 依赖，集成第三方，启动类，扫描并加载所在包以及子包的 Bean，开启自动配置功能，发现并加载自动配置类，根据条件注解等，实现自动装配。</strong></p>
<p><code>@SpringApplication</code>是Spring Boot的核心注解，它包含了<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>等注解。</p>
<ul>
<li><code>@SpringBootConfiguration</code>：声明当前类是配置类，允许使用<code>@Bean</code>注解定义bean。</li>
<li><code>@EnableAutoConfiguration</code>：根据项目的依赖关系，自动配置Spring Boot项目。</li>
<li><code>@ComponentScan</code>：让Spring扫描到Configuration类并把它加入到程序上下文。</li>
</ul>
<p>SpringBoot的自动装配原理主要基于Spring框架的依赖注入和条件化Bean机制，并结合SpringBoot的特定功能和设计原则实现的。</p>
<p>首先，SpringBoot通过引入一系列starter依赖，使得开发者能够便捷地集成各种第三方库和框架。每个starter都包含了一系列预定义的配置和Bean定义，用于简化特定功能的集成过程。</p>
<p>在SpringBoot应用启动时，<code>@SpringBootApplication</code>注解起到了关键作用。这个注解实际上是一个复合注解，其中<code>@EnableAutoConfiguration</code>是实现自动装配的核心。它告诉SpringBoot开启自动配置功能。</p>
<p>SpringBoot的自动配置功能通过加载<code>META-INF/spring.factories</code>文件来发现并加载各种自动配置类。这些自动配置类使用条件注解（如<code>@ConditionalOnClass</code>、<code>@ConditionalOnProperty</code>等）来确定是否应该创建和配置特定的Bean。条件注解允许根据类路径、属性设置、Bean是否存在等条件来启用或禁用自动配置。</p>
<p>当SpringBoot启动时，它会扫描这些自动配置类，并根据条件注解的判断来决定是否创建和注册相应的Bean到Spring容器中。如果某个自动配置类满足其条件注解指定的条件，那么它定义的Bean就会被创建并注入到Spring容器中，从而完成自动装配过程。</p>
<p>除了自动配置类，SpringBoot还利用了一些核心组件来实现自动装配，如<code>AutoConfigurationImportSelector</code>和<code>SpringFactoriesLoader</code>。<code>AutoConfigurationImportSelector</code>负责从<code>spring.factories</code>中加载自动配置类，并根据条件进行筛选。<code>SpringFactoriesLoader</code>则用于加载<code>META-INF/spring.factories</code>文件中定义的配置。</p>
<p>通过这种方式，SpringBoot能够自动配置应用的很多方面，如数据库连接、消息队列、Web服务等，从而大大简化了开发者的配置工作，提高了开发效率。</p>
<p>需要注意的是，虽然自动装配能够极大地简化配置工作，但在某些情况下，开发者仍然需要手动配置一些Bean或覆盖自动配置的默认设置，以满足特定的业务需求。因此，理解SpringBoot的自动装配原理并熟悉其配置方式，对于开发者来说是非常重要的。</p>
<h3 id="Spring-的扩展点"><a href="#Spring-的扩展点" class="headerlink" title="Spring 的扩展点"></a>Spring 的扩展点</h3><h2 id="简单知识复盘"><a href="#简单知识复盘" class="headerlink" title="简单知识复盘"></a>简单知识复盘</h2><p>怎么让两个线程轮流执行？使用wait()和notify()。一个线程执行完之后调用notify()唤醒正在等待中的线程，自身调用wait()进入等待状态。</p>
<p>static静态变量有什么优势/缺点？节省内存空间，方便访问；数据不一致，难以理解和维护。</p>
<p>UDP与TCP比较。无连接，不可靠，实时性较高，能容忍一定的数据丢失，不保证数据的顺序性完整性，没有序列号、确认机制、超市重传、流量控制、拥塞控制。</p>
<p>为什么选择 Redis?Redis 是单独的中间件，不同客户端把session存放在redis上，实现在分布式结构中的资源可见性，解决用户登录失效问题；Redis 单线程，支持 lua 脚本，保证了并发操作安全的同时，能很好地实现分布式锁；作为缓存数据库，存储热门数据，减轻数据库压力。</p>
<p>项目的开发流程：参考已有的产品学习了解，总结比较好的功能点。结合自己扩展的功能特色，做整体设计，经过需求分析后得到产品原型。选用合适的技术，解决具体的业务问题。</p>
<p>为什么使用 Dubbo RPC？首先为了减小网关模块的体量，避免引入复杂的业务逻辑，保证设计模式遵循的单一原则，决定使用 RPC 实现服务间调用。OpenFeign 的方式也考虑过，本质上是构建 HTTP 请求，发送请求去调用对外提供的服务。这种方式需要添加很多请求头，使用 JSON 序列化的效率也不高，更加适合外部服务。选用 Dubbo，基于 TCP 协议，避免无用的请求头，序列化为二进制流传输，效率高。</p>
<p>如何使用 RPC 框架？详细的业务流程。实现服务间交互，先说说具体的技术选型👆和实现原理（Nacos 注册中心、服务消费者、服务生产者等），获取用户相关信息，用户是否存在，有没有权限调用，API 签名校验是否通过；获取接口相关信息，接口是否存在，免费的还是付费的，是否发布或者已下线；做好接口调用统计，在 HaddleResponse 处理器中，发起 RPC调用，操作数据库，用户可调用次数减少、接口被调用次数增加（如何实现？👇）。</p>
<p>网关保证接口可用和稳定性，隐藏真实的接口地址，请求转发。实现全局过滤，获取请求头的一切信息：请求参数、请求路径、请求来源地址等。做 API 签名校验，鉴定用户身份；根据请求路路径和方法判断接口状态，是否存在，是否发布或下线；设置 ip 黑白名单，只允许当前服务器的请求可以通过；流量染色，给请求添加统一的请求头。完成一系列校验之后，将该合法请求转发给真正的接口服务，处理接口调用，返回响应。最后在 haddleReponse 响应处理器中，完成接口调用统计等业务逻辑，更新相关字段，比如用户剩余调用次数、接口调用总次数等。返回响应，结束整个调用流程。</p>
<p>接口调用次数排行怎么实现？每次接口调用完成，在 haddleResponse 处理器中发起 RPC 请求，更新数据库。并发请求下，会出现统计不准确的问题。没有在业务层面加锁，数据库并发写，压力太大。可以使用 Redis，Sorted Set 数据结构，score 权值实现排序。不使用加锁影响效率，同时单线程 Redis 很好解决并发问题。持久化。</p>
<p>怎么实现 SDK 的？实现过程 + 实现原理。添加依赖，编写自动配置类，添加 @Configuration 注解；在 resouce / MEATA-INF 下的 spring.factories 文件下，指定自动配置类的全路径；绑定配置文件，@ CofigurationProperties 加载配置文件，映射为 Java 类；执行 mvn install 命令，安装到本地仓库，其他模块导入依赖后，编写配置文件中的 ak，sk，即可拿到客户端 SDK 对象，发起接口调用。</p>
<p>实现原理就是 Spring Boot 自动装配机制。</p>
<p>一个对象的创建流程？（最好能接着说类加载机制；最好能说出创建对象有几种方式：反射，序列化，unsafe类实现Cloneable接口重写clone方法）</p>
<p>arrayList 的 remove 是怎么实现的？从列表中删除指定元素，有多种重载形式。按值删除，遍历整个列表寻找给定元素，找到就删除，同时将后面元素向前移动一个位置。按索引删除，直接定位到给定索引的元素，执行删除操作。</p>
<p>Java 8 的新特性有用过哪些？stream 流，Date/Time API，BigDecimal，Optional 容器等。</p>
<p>有了解过 HashMap 的 put() 和扩容机制吗？有了解过 ArayList 的 add() 和扩容机制吗？</p>
<p>对于开源框架的深入理解，比如Spring 的启动流程、Spring IOC 创建流程、Bean 的生命周期、Spring MVC 处理流程、Spring Boot 的启动流程和自动配置原理、Spring Boot 的扩展点等。了解了这些，就更能认识到 Spring Boot 的简洁和快速。</p>
<p><strong>设计模式的七大原则</strong>：</p>
<ul>
<li>单一职责原则：一个类应该只有一个引起变化的原因。</li>
<li>开放封闭原则：软件实体（类、模块、函数等）应该是可扩展的，但是不可修改。</li>
<li>里氏替换原则：子类必须能够替换其基类。</li>
<li>接口隔离原则：使用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。</li>
<li>依赖倒置原则：要依赖于抽象，不要依赖于具体。</li>
<li>迪米特法则（最少知道原则）：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li>合成复用原则：尽量使用合成/聚合的方式，而不是使用继承。</li>
</ul>
<p>for 循环使用迭代器删除元素</p>
<p><strong>解决慢SQL问题</strong></p>
<p>解决慢SQL问题通常涉及以下步骤：</p>
<ul>
<li>使用SQL执行计划分析查询。</li>
<li>优化索引，确保查询能够高效利用索引。</li>
<li>避免在查询中使用SELECT *，只选择需要的字段。</li>
<li>减少JOIN操作或优化JOIN条件。</li>
<li>避免在WHERE子句中使用非SARGable函数。</li>
<li>考虑对数据库进行分区或分片。</li>
<li>监控数据库性能，定期审查和调整SQL语句。</li>
</ul>
<p><strong>分布式锁的实现方式</strong></p>
<p>分布式锁的实现方式有多种，包括但不限于：</p>
<ul>
<li>基于数据库实现，如使用数据库的排他锁。</li>
<li>基于Redis实现，利用Redis的setnx命令或RedLock算法。</li>
<li>基于Zookeeper实现，利用Zookeeper的临时顺序节点和watch机制。</li>
</ul>
<p><strong>线程池的核心参数通常包括</strong></p>
<ul>
<li>corePoolSize：核心线程数，即使线程处于空闲状态，也不会被销毁，除非设置了allowCoreThreadTimeOut。</li>
<li>maximumPoolSize：线程池允许的最大线程数。</li>
<li>keepAliveTime：线程空闲时间，当线程数大于核心线程数时，此为终止前多余的空闲线程等待新任务的最长时间。</li>
<li>workQueue：用于存放待执行的任务的阻塞队列。</li>
</ul>
<p>拒绝策略有四种：</p>
<ul>
<li>AbortPolicy：直接抛出RejectedExecutionException异常。</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务。</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中等待最久的任务，然后重新尝试执行任务。</li>
<li>DiscardPolicy：直接丢弃任务，不处理。</li>
</ul>
<p><strong>JVM如何判断对象存活</strong></p>
<p>JVM通过垃圾回收器来判断对象是否存活。主要使用两种算法：引用计数法和可达性分析。现代JVM主要使用可达性分析算法。</p>
<p>可达性分析的基本思路是：从一系列称为“GC Roots”的对象开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p>在Java中，可作为GC Roots的对象包括：</p>
<ul>
<li>虚拟机栈中引用的对象，如方法中的局部变量。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>JNI（Java Native Interface）中引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ul>
<p>当进行垃圾回收时，JVM会遍历这些GC Roots，然后递归地搜索它们所引用的对象，标记为存活。未被标记的对象则被认为是不可达的，即垃圾对象，可以被回收。</p>
<p><strong>ConcurrentHashMap的实现原理及扩容机制</strong></p>
<p><strong>实现原理</strong>:</p>
<ul>
<li><code>ConcurrentHashMap</code>（简称CHM）是Java并发包<code>java.util.concurrent</code>下提供的一个线程安全的HashMap实现。</li>
<li>CHM内部将数据分为多个段（Segment），每个段其实就是一个小的HashMap，每个段都有自己的锁。这样，多线程并发访问时，不同段的数据可以并行处理，从而提高并发性能。</li>
<li>每个段内部使用链表+红黑树的组合来存储键值对，当链表长度超过一定阈值（TREEIFY_THRESHOLD，默认为8）时，会转化为红黑树来优化查询性能；当树的大小小于UNTREEIFY_THRESHOLD（默认为6）时，会退化为链表。</li>
</ul>
<p><strong>扩容机制</strong>:</p>
<ul>
<li>当CHM中的元素数量超过当前容量的某个阈值时（通常是容量的0.75倍），会触发扩容。</li>
<li>扩容时，会创建一个新的数组，其容量是原数组的两倍。</li>
<li>然后遍历原数组中的每个段，重新计算每个键值对的索引位置，并放入新数组中。</li>
<li>为了保证线程安全，这个过程会采用分段锁的方式，确保同一时间只有一个线程在扩容某个段。</li>
</ul>
<p><strong>GC算法</strong>:</p>
<ul>
<li><strong>标记-清除（Mark-Sweep）</strong>: 分为两个阶段，标记阶段从根对象开始递归访问所有可达对象并标记它们，清除阶段则回收未被标记的对象。优点是简单，但缺点是会产生内存碎片。</li>
<li><strong>复制（Copying）</strong>: 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。优点是简单且没有内存碎片，但缺点是内存利用率低。</li>
<li><strong>标记-整理（Mark-Compact）</strong>: 标记阶段和标记-清除算法相同，但在清除阶段会将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。优点是解决了内存碎片问题，但缺点是效率相对较低。</li>
<li><strong>分代收集（Generational Collection）</strong>: 根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收。</li>
</ul>
<p><strong>优缺点</strong>:</p>
<ul>
<li><strong>标记-清除</strong>: 优点是实现简单，缺点是会产生内存碎片，需要定期进行内存碎片整理。</li>
<li><strong>复制</strong>: 优点是避免了内存碎片问题，缺点是内存利用率低，只适合对象存活率较低的场景。</li>
<li><strong>标记-整理</strong>: 优点是解决了内存碎片问题，且内存利用率高，但缺点是算法效率相对较低。</li>
<li><strong>分代收集</strong>: 优点是结合了多种算法的优点，根据对象的存活周期选择合适的算法，提高了垃圾收集的效率。缺点是实现相对复杂。</li>
</ul>
<p><strong>对象的生命周期</strong>:</p>
<ul>
<li><strong>创建阶段</strong>: 使用new关键字或者反射API等方式创建对象实例。</li>
<li><strong>使用阶段</strong>: 对象被程序引用并使用，执行相应的操作。</li>
<li><strong>不可达阶段</strong>: 当对象没有任何引用指向它时，该对象就变得不可达了。此时，它将被垃圾收集器标记为可回收。</li>
<li><strong>回收阶段</strong>: 在垃圾收集器运行期间，不可达的对象会被清理掉，释放其占用的内存空间。</li>
</ul>
<p><strong>项目中的数据权限怎么实现</strong></p>
<p>数据权限的实现通常涉及到以下几个方面：</p>
<ul>
<li><strong>基于角色的权限控制</strong>: 为不同的角色分配不同的数据访问权限。例如，管理员可以访问所有数据，而普通用户只能访问自己的数据。</li>
<li><strong>基于数据字段的权限控制</strong>: 对于某些敏感字段，可以设定只有特定角色或用户才能查看或修改。</li>
<li><strong>数据行级权限控制</strong>: 根据某些条件（如用户ID、部门ID等）来控制用户能够访问的数据行。</li>
<li><strong>权限校验</strong>: 在用户访问数据时，系统需要进行权限校验，确保用户只能访问其被授权的数据。这通常涉及到在业务逻辑中加入权限判断的代码，或者通过数据库层面的视图、存储过程等来实现。</li>
<li><strong>日志记录</strong>: 记录用户对数据的访问和操作行为，以便在发生问题时进行审计和追踪。</li>
</ul>
<p><strong>Java中的锁机制</strong>是用于处理多线程并发情况下数据一致性的重要工具。在Java中，有多个层面的锁机制，包括synchronized关键字和Lock接口等。</p>
<ol>
<li>synchronized关键字<ul>
<li>这是Java语言内置的一种锁机制。</li>
<li>它可以用来实现对代码块或方法的同步控制，确保同一时刻只有一个线程可以执行被锁定的代码块或方法。</li>
<li>当一个线程获取锁时，它会将对象头中的标志位设置为锁定状态，其他线程在尝试获取锁时，如果发现标志位已被设置为锁定状态，就会进入等待状态，直到锁被释放。</li>
</ul>
</li>
<li>Lock接口<ul>
<li>提供了比synchronized更灵活的锁机制。</li>
<li>它提供了显式的锁获取和释放操作，允许更细粒度的控制。</li>
<li>Lock接口有多种实现，包括ReentrantLock等。</li>
</ul>
</li>
</ol>
<p>在Java的锁机制中，还可以根据锁的特性进行进一步分类：</p>
<ol>
<li>公平锁与非公平锁<ul>
<li>公平锁：按照线程申请锁的顺序来获取锁，类似于日常排队。</li>
<li>非公平锁：线程获取锁的顺序并不是按照申请锁的顺序，可能存在插队现象。</li>
</ul>
</li>
<li>可重入锁（递归锁）<ul>
<li>允许同一线程在外层方法获取锁后，进入内层方法时仍能持有该锁并继续运行。</li>
</ul>
</li>
<li>自旋锁<ul>
<li>当线程尝试获取锁失败时，不是立即阻塞等待，而是采用循环的方式尝试获取锁。</li>
<li>这可以减少线程上下文切换的消耗，但当循环次数过多时，会消耗CPU资源。</li>
</ul>
</li>
<li>读写锁<ul>
<li>分为写锁和读锁。写锁是独占锁，一次只能被一个线程持有；读锁是共享锁，可被多个线程持有。</li>
<li>读写锁适用于读操作远多于写操作的场景，可以大大提高读操作的性能。</li>
</ul>
</li>
</ol>
<p>Java的锁机制为多线程编程提供了丰富的工具，开发者可以根据具体的业务需求选择适合的锁类型，以确保数据的一致性和线程的安全性。</p>
<p>好的，针对您提出的问题，我将逐一进行回答：</p>
<p><strong>1、介绍一下 Redis</strong></p>
<p>Redis 是一个开源的使用 ANSI C 语言编写的、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(string)、哈希(Hash)、列表(list)、集合(sets)、有序集合(sorted sets) 等类型。Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启后可以再次加载进行使用。</p>
<p><strong>2、介绍一下 Redis 的数据结构及其底层实现原理</strong></p>
<p>Redis 支持多种数据结构，每种数据结构都有其特定的底层实现原理：</p>
<ul>
<li><strong>字符串（String）</strong>：字符串是最简单的数据类型，其底层实现就是一个简单的动态字符串。当对这个字符串进行修改的时候，如果超过了当前分配的空间，会进行2倍的空间扩展。</li>
<li><strong>哈希（Hash）</strong>：哈希类型实际上是 field 和 value 的映射表，类似于 Java 中的 HashMap。Redis 的哈希类型底层实现为压缩列表或哈希表两种数据结构。当哈希类型元素较少时，使用压缩列表；当元素较多时，则使用哈希表。</li>
<li><strong>列表（List）</strong>：列表类型用来存储多个有序的字符串元素，列表中的元素可以重复。列表类型有两个特点：可以添加重复的元素和保留元素插入的顺序。其底层实现为双向链表或压缩列表。</li>
<li><strong>集合（Set）</strong>：集合类型用来存储多个无序的字符串元素，且集合中的元素不能重复。其底层实现为整数集合或哈希表。</li>
<li><strong>有序集合（Sorted Set）</strong>：有序集合与集合一样不允许有重复的元素，但每个元素都会关联一个 double 类型的分数，Redis 正是通过分数来为集合中的元素从小到大进行从小到大的排序。其底层实现为压缩列表或跳跃表和哈希表的组合。</li>
</ul>
<p><strong>3、介绍一下你对 Redis 线程模型的了解</strong></p>
<p>Redis 是单线程模型，这里的单线程主要指的是 Redis 的网络 I/O 和键值对读写是由一个线程来完成的。虽然 Redis 的其他功能，如持久化、异步删除、集群数据同步等，是由额外的线程来处理的，但这些并不会影响 Redis 主线程处理网络 I/O 和键值对读写的工作。Redis 采用单线程模型主要是为了避免多线程带来的锁竞争和上下文切换的开销，从而确保 Redis 的高性能。</p>
<p><strong>4、介绍一下 Redis 集群，以及 Redis 是如何实现高可用的</strong></p>
<p>Redis 集群是一个提供在多个 Redis 节点间进行数据共享的程序集。Redis 集群不支持那些需要同时操作多个键的 Redis 命令，因为这需要在不同的节点间移动数据，从而无法达到像单个 Redis 实例那样的性能，在设计的时候这就是不被支持的。</p>
<p>Redis 实现高可用主要通过以下几种方式：</p>
<ul>
<li><strong>主从复制</strong>：Redis 支持主从复制功能，即一个主节点可以有多个从节点。当主节点出现故障时，从节点可以接管主节点的任务，继续提供服务，从而实现高可用。</li>
<li><strong>哨兵（Sentinel）</strong>：哨兵是 Redis 的高可用性解决方案：由一个或多个 Sentinel 节点组成的 Sentinel 系统可以监视任意数量的主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。</li>
<li><strong>集群（Cluster）</strong>：Redis 集群实现了数据的分片存储，每个节点只存储部分数据。当某个节点出现故障时，其他节点仍然可以正常工作，并且可以通过重新分配数据来恢复数据的完整性。此外，Redis 集群还支持在线扩容，可以方便地添加新的节点来提高系统的处理能力和存储容量。</li>
</ul>
<p><strong>5、说一下 Redis 中的 hot key 应该如何处理</strong></p>
<p>hot key 是指那些被频繁访问的 Redis 键。处理 hot key 可以从以下几个方面入手：</p>
<ul>
<li><strong>缓存穿透</strong>：当查询一个不存在的数据时，由于缓存中也没有，因此每次请求都会直接打到数据库上，造成缓存穿透。对于这类情况，我们可以将空对象或默认值进行缓存，或者对查询条件进行校验，避免无效的查询。</li>
<li><strong>缓存雪崩</strong>：当缓存中大量的 key 在同一时间失效或者 Redis 服务宕机时，所有的请求都会直接打到数据库上，造成缓存雪崩。为了避免这种情况，我们可以设置不同的 key 的过期时间，或者使用 Redis 的持久化功能来确保数据的可靠性。</li>
<li><strong>热点 key 的访问</strong>：对于热点 key，我们可以考虑使用分布式锁来限制并发访问，或者使用本地缓存来减少对 Redis 的访问次数。此外，还可以考虑对热点 key 进行拆分或者增加其副本数量来分散访问压力。</li>
</ul>
<p><strong>6、你用过 Redis 吗？说一下你在哪些场景下用的</strong></p>
<p>是的，我在实际项目中经常使用 Redis。以下是一些我使用 Redis 的场景：</p>
<ul>
<li><p><strong>缓存</strong>：这是 Redis 最常见的使用场景。我将一些热点数据或者计算结果存储在 Redis 中，作为缓存使用，以减少对数据库的访问压力，提高系统的响应速度。</p>
</li>
<li><p><strong>计数器</strong>：Redis 的原子操作特性使得它非常适合用于实现计数器功能。例如，我可以使用 Redis 来记录网站的访问量、用户的点赞数等。</p>
</li>
<li><p><strong>排行榜</strong>：Redis 的有序集合（Sorted Set）数据结构使得实现排行榜功能变得非常简单。我可以根据分数将元素进行排序，从而轻松获取排行榜信息。</p>
</li>
<li><p><strong>消息队列</strong>：Redis 的列表（List）数据类型可以被用作简单的消息队列。生产者可以将消息推送到队列中，消费者可以从队列中拉取消息进行处理。</p>
</li>
<li><p><strong>分布式锁</strong>：Redis 的 setnx 命令可以实现分布式锁的功能。在多个进程或线程需要同时访问共享资源时，我可以使用 Redis 的分布式锁来确保资源的安全访问。</p>
</li>
<li><p><strong>会话管理</strong>：在 Web 应用中，我可以将用户的会话信息存储在 Redis 中，实现跨服务器的会话共享。</p>
</li>
<li><p><strong>社交功能</strong>：Redis 也常被用于实现一些社交功能，如用户的关注列表、粉丝列表等。由于这些列表通常需要频繁地进行添加、删除和查询操作，Redis 的高性能特性使得它成为实现这些功能的理想选择。</p>
<p>以上只是我使用 Redis 的一些常见场景，实际上 Redis 的应用场景非常广泛，几乎涵盖了所有需要高性能数据存储和访问的场景。</p>
</li>
</ul>
<h2 id="面经总结"><a href="#面经总结" class="headerlink" title="面经总结"></a>面经总结</h2><h3 id="1-自我介绍及项目中的技术问题和优化"><a href="#1-自我介绍及项目中的技术问题和优化" class="headerlink" title="1. 自我介绍及项目中的技术问题和优化"></a>1. 自我介绍及项目中的技术问题和优化</h3><p><strong>自我介绍</strong>：<br>我是一名具有多年经验的Java开发工程师，专注于后端开发，对Java生态系统中的技术和框架有深入的了解。</p>
<p><strong>项目中的技术问题和优化</strong>：<br>在最近的项目中，我们遇到了系统在高并发场景下性能下降的问题。经过分析，发现是由于数据库访问过于频繁导致的。为了解决这个问题，我引入了缓存机制，使用Redis缓存热点数据，减少了数据库访问次数，从而提升了系统性能。</p>
<p>此外，我还对系统中的某些算法进行了优化，比如使用了更高效的数据结构和算法，减少了计算复杂度，提高了处理速度。</p>
<h3 id="2-ArrayList和LinkedList的介绍及优雅创建ArrayList"><a href="#2-ArrayList和LinkedList的介绍及优雅创建ArrayList" class="headerlink" title="2. ArrayList和LinkedList的介绍及优雅创建ArrayList"></a>2. ArrayList和LinkedList的介绍及优雅创建ArrayList</h3><p><strong>ArrayList</strong>：<br>ArrayList是基于动态数组实现的List接口，支持随机访问元素，但在插入和删除元素时可能需要移动其他元素，因此效率较低。</p>
<p><strong>LinkedList</strong>：<br>LinkedList是基于链表实现的List接口，插入和删除元素时效率较高，但访问元素时需要从头或尾开始遍历，因此随机访问效率较低。</p>
<p><strong>优雅创建ArrayList</strong>：<br>在创建ArrayList时，如果预先知道要存储的元素数量，可以通过构造函数指定初始容量，以避免多次扩容带来的性能开销。例如：<code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(10);</code></p>
<h3 id="3-HashMap底层为何进化成红黑树及红黑树关键点"><a href="#3-HashMap底层为何进化成红黑树及红黑树关键点" class="headerlink" title="3. HashMap底层为何进化成红黑树及红黑树关键点"></a>3. HashMap底层为何进化成红黑树及红黑树关键点</h3><p><strong>进化成红黑树的原因</strong>：<br>当HashMap中的某个桶（bucket）的链表长度过长时，查找效率会降低。为了解决这个问题，HashMap在JDK 1.8中引入了红黑树来优化性能。当红黑树的节点数少于一定数量时，会退化为链表，以保持简单性。</p>
<p><strong>红黑树关键点</strong>：<br>红黑树是一种自平衡的二叉搜索树，它满足以下五个性质：</p>
<ul>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点是黑色。</li>
<li>所有叶子节点（NIL或空节点）是黑色。</li>
<li>如果一个节点是红色的，则它的两个子节点都是黑色的。</li>
<li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。</li>
</ul>
<h3 id="4-HashMap解决哈希冲突的方式"><a href="#4-HashMap解决哈希冲突的方式" class="headerlink" title="4. HashMap解决哈希冲突的方式"></a>4. HashMap解决哈希冲突的方式</h3><p>HashMap解决哈希冲突的方式主要有两种：</p>
<ul>
<li><strong>拉链法</strong>：将哈希值相同的元素存储在同一个桶的链表中。</li>
<li><strong>红黑树法</strong>（在JDK 1.8及以后）：当某个桶的链表长度过长时，会转换为红黑树来存储元素，以提高查找效率。</li>
</ul>
<h3 id="5-Java中哪里用到了开放定址法"><a href="#5-Java中哪里用到了开放定址法" class="headerlink" title="5. Java中哪里用到了开放定址法"></a>5. Java中哪里用到了开放定址法</h3><p>在Java中，<strong>ThreadLocal</strong>并没有直接使用开放定址法来解决哈希冲突。ThreadLocal内部使用了一个简单的哈希表来存储线程局部变量，但具体的冲突解决策略并不是开放定址法。通常，ThreadLocal的哈希表大小是固定的，并且每个线程都有一个独立的ThreadLocalMap实例，因此哈希冲突的情况相对较少。</p>
<h3 id="6-ThreadLocal底层实现原理及并发解决方式"><a href="#6-ThreadLocal底层实现原理及并发解决方式" class="headerlink" title="6. ThreadLocal底层实现原理及并发解决方式"></a>6. ThreadLocal底层实现原理及并发解决方式</h3><p><strong>ThreadLocal底层实现原理</strong>：<br>ThreadLocal为每个线程提供其自己的变量副本。每个线程在第一次访问某个ThreadLocal变量时，ThreadLocal通过调用其setInitialValue()方法为该线程创建变量副本，并在ThreadLocalMap中以线程为键保存。后续对该变量的访问或修改都是基于线程自己的副本进行的，因此不会影响其他线程。</p>
<p><strong>并发解决方式</strong>：<br>ThreadLocal通过为每个线程提供独立的变量副本来解决并发问题。由于每个线程都有自己的变量副本，因此不存在多线程间的数据竞争和同步问题。</p>
<h3 id="7-ThreadLocal使用产生的问题、原因及解决方案"><a href="#7-ThreadLocal使用产生的问题、原因及解决方案" class="headerlink" title="7. ThreadLocal使用产生的问题、原因及解决方案"></a>7. ThreadLocal使用产生的问题、原因及解决方案</h3><p><strong>产生的问题</strong>：</p>
<ul>
<li><strong>内存泄漏</strong>：由于ThreadLocalMap的生命周期与线程的生命周期相同，如果线程长时间运行而不结束，那么ThreadLocalMap中存储的键值对（包括ThreadLocal的弱引用和变量的强引用）也无法被垃圾回收，从而导致内存泄漏。</li>
</ul>
<p><strong>原因</strong>：</p>
<ul>
<li>ThreadLocalMap使用ThreadLocal的弱引用作为键，而值是强引用。当ThreadLocal不再被引用时，由于它是弱引用，可以被垃圾回收。但是，如果ThreadLocalMap不被清理，那么它仍然持有值的强引用，导致内存泄漏。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>在使用完ThreadLocal后，显式调用其remove()方法，从当前线程的ThreadLocalMap中移除对应的条目。</li>
<li>设计合理的线程池管理策略，避免线程长时间运行。</li>
</ul>
<h3 id="8-手动实现Redis分布式锁"><a href="#8-手动实现Redis分布式锁" class="headerlink" title="8. 手动实现Redis分布式锁"></a>8. 手动实现Redis分布式锁</h3><p>实现Redis分布式锁通常涉及以下步骤：</p>
<ol>
<li>使用Redis的SETNX命令尝试设置一个锁键，并设置过期时间。</li>
<li>如果设置成功，则获取到锁，执行临界区代码。</li>
<li>执行完临界区代码后，删除锁键。</li>
<li>如果设置失败（即锁已被其他客户端持有），则等待或重试。</li>
</ol>
<p>在实现过程中，需要注意以下几点：</p>
<ul>
<li><strong>锁的粒度</strong>：锁的粒度应该尽可能小，以减少锁竞争。</li>
<li><strong>锁的过期时间</strong>：设置合理的过期时间，避免锁因客户端崩溃或网络问题而长时间无法释放。</li>
<li><strong>锁的续期</strong>：如果临界区代码执行时间较长，可能需要考虑锁的续期，以避免过期后被其他客户端误抢。</li>
<li><strong>避免死锁</strong>：确保在异常情况下能够释放锁，避免死锁。</li>
</ul>
<h3 id="9-实现Redis分布式锁时加锁和释放锁需注意的事项"><a href="#9-实现Redis分布式锁时加锁和释放锁需注意的事项" class="headerlink" title="9. 实现Redis分布式锁时加锁和释放锁需注意的事项"></a>9. 实现Redis分布式锁时加锁和释放锁需注意的事项</h3><p><strong>加锁时需注意</strong>：</p>
<ul>
<li>设置锁的键值时，应使用唯一标识（如UUID）作为锁的值，以便于识别锁的持有者。</li>
<li>设置锁的过期时间，确保锁不会因客户端异常而长时间持有。</li>
<li>考虑使用Redis的事务或Lua脚本来保证加锁操作的原子性。</li>
</ul>
<p><strong>释放锁时需注意</strong>：</p>
<ul>
<li>在删除锁键之前，应验证当前客户端是否确实持有该锁（即锁的值是否与客户端设置的唯一标识匹配）。</li>
<li>仅当客户端确实持有锁时，才应删除锁键，以避免误删其他客户端的锁。</li>
<li>考虑使用Redis的事务或Lua脚本来保证释放锁操作的原子性。</li>
</ul>
<h3 id="10-Redis淘汰策略中的LRU和LFU，问题及LFU后续版本的改进"><a href="#10-Redis淘汰策略中的LRU和LFU，问题及LFU后续版本的改进" class="headerlink" title="10. Redis淘汰策略中的LRU和LFU，问题及LFU后续版本的改进"></a>10. Redis淘汰策略中的LRU和LFU，问题及LFU后续版本的改进</h3><p><strong>LRU（Least Recently Used）</strong>：<br>LRU算法淘汰最久未使用的数据。但问题在于，它无法很好地处理“冷数据”突然变为“热数据”的情况。即使这些数据最近被访问过，但由于它们之前长时间未被访问，仍可能被错误地淘汰。</p>
<p><strong>LFU（Least Frequently Used）</strong>：<br>LFU算法根据数据的访问频率来淘汰数据。但它也有问题：一旦某个数据变为热数据，即使之后访问频率降低，它也可能因为之前的高访问频率而长时间留在缓存中。</p>
<p><strong>LFU后续版本的改进</strong>：<br>为了解决LFU的上述问题，后续版本引入了<strong>降频机制</strong>。降频机制的基本思想是：对于长时间未被访问但访问频率仍然很高的数据，逐渐降低其访问频率计数，使其更容易被淘汰。这样既能保证热数据在缓存中的留存，又能避免冷数据被错误地保留。具体实现时，可以通过为每个数据的访问频率计数设置一个衰减因子或时间窗口来实现降频。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/blog/categories/%E6%97%A5%E8%AE%B0/" class="category-chain-item">日记</a>
  
  
    <span>></span>
    
  <a href="/blog/categories/%E6%97%A5%E8%AE%B0/%E6%B1%82%E8%81%8C%E7%BB%8F%E9%AA%8C/" class="category-chain-item">求职经验</a>
  
  
    <span>></span>
    
  <a href="/blog/categories/%E6%97%A5%E8%AE%B0/%E6%B1%82%E8%81%8C%E7%BB%8F%E9%AA%8C/%E5%AE%9E%E4%B9%A0/" class="category-chain-item">实习</a>
  
  
    <span>></span>
    
  <a href="/blog/categories/%E6%97%A5%E8%AE%B0/%E6%B1%82%E8%81%8C%E7%BB%8F%E9%AA%8C/%E5%AE%9E%E4%B9%A0/%E5%B7%A5%E4%BD%9C/" class="category-chain-item">工作</a>
  
  

  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/blog/tags/%E6%97%A5%E8%AE%B0/">#日记</a>
      
        <a href="/blog/tags/%E6%B1%82%E8%81%8C%E7%BB%8F%E9%AA%8C/">#求职经验</a>
      
        <a href="/blog/tags/%E5%AE%9E%E4%B9%A0/">#实习</a>
      
        <a href="/blog/tags/%E5%B7%A5%E4%BD%9C/">#工作</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>从零开始：我的软工求职路</div>
      <div>https://deng-2022.gitee.io/blog/2024/03/07/从零开始：我的软工求职路/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Memory</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2024/01/17/%E7%B9%81%E6%98%9F%E7%82%B9%E7%82%B9%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E5%88%AB%E5%85%B7%E4%B8%80%E6%A0%BC%E7%9A%84%20Spring%20Boot%20%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6/" title="繁星点点：从零开始构建别具一格的 Spring Boot 项目框架">
                        <span class="hidden-mobile">繁星点点：从零开始构建别具一格的 Spring Boot 项目框架</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      

    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.fluid-dev.com/docs/guide/" target="_blank" rel="nofollow noopener"> <span>Memory | 个人文档站点</span> </a>
<i class="iconfont icon-love"></i> <a href="https://hexo.fluid-dev.com/docs/guide/" target="_blank" rel="nofollow noopener"> <span>配置指南 | Hexo Fluid 用户手册</span> </a>   
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      京ICP证123456号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/blog/img/police_beian.png" alt="police-icon"/>
          
          <span>京公网安备12345678号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/blog/js/local-search.js" ></script>

  <script defer src="/blog/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/blog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
